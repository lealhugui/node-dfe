<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.14: http://docutils.sourceforge.net/" />
<title>generateDS -- Introduction and Tutorial</title>
<meta name="author" content="Dave Kuhlman" />
<style type="text/css">

/* css */

body {
  font: 90% 'Lucida Grande', Verdana, Geneva, Lucida, Arial, Helvetica, sans-serif;
  background: #ffffff;
  color: black;
  margin: 2em;
  padding: 2em;
}

a[href] {
  color: #436976;
  background-color: transparent;
}

a.toc-backref {
  text-decoration: none;
}

h1 a[href] {
  text-decoration: none;
  color: #fcb100;
  background-color: transparent;
}

a.strong {
  font-weight: bold;
}

img {
  margin: 0;
  border: 0;
}

p {
  margin: 0.5em 0 1em 0;
  line-height: 1.5em;
}
p a {
  text-decoration: underline;
}
p a:visited {
  color: purple;
  background-color: transparent;
}
p a:active {
  color: red;
  background-color: transparent;
}
a:hover {
  text-decoration: none;
}
p img {
  border: 0;
  margin: 0;
}

h1, h2, h3, h4, h5, h6 {
  color: #003a6b;
  background-color: transparent;
  font: 100% 'Lucida Grande', Verdana, Geneva, Lucida, Arial, Helvetica, sans-serif;
  margin: 0;
  padding-top: 0.5em;
}

h1 {
  font-size: 160%;
  margin-bottom: 0.5em;
  border-bottom: 1px solid #fcb100;
}
h2 {
  font-size: 140%;
  margin-bottom: 0.5em;
  border-bottom: 1px solid #aaa;
}
h3 {
  font-size: 130%;
  margin-bottom: 0.5em;
  text-decoration: underline;
}
h4 {
  font-size: 110%;
  font-weight: bold;
}
h5 {
  font-size: 100%;
  font-weight: bold;
}
h6 {
  font-size: 80%;
  font-weight: bold;
}

ul a, ol a {
  text-decoration: underline;
}

dt {
  font-weight: bold;
}
dt a {
  text-decoration: none;
}

dd {
  line-height: 1.5em;
  margin-bottom: 1em;
}

legend {
  background: #ffffff;
  padding: 0.5em;
}

form {
  margin: 0;
}


dl.form {
  margin: 0;
  padding: 1em;
}

dl.form dt {
  width: 30%;
  float: left;
  margin: 0;
  padding: 0 0.5em 0.5em 0;
  text-align: right;
}

input {
  font: 100% 'Lucida Grande', Verdana, Geneva, Lucida, Arial, Helvetica, sans-serif;
  color: black;
  background-color: white;
  vertical-align: middle;
}

abbr, acronym, .explain {
  color: black;
  background-color: transparent;
}

q, blockquote {
}

code, pre {
  font-family: monospace;
  font-size: 1.2em;
  display: block;
  padding: 10px;
  border: 1px solid #838183;
  background-color: #eee;
  color: #000;
  overflow: auto;
  margin: 0.5em 1em;
}

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

tt.docutils {
  background-color: #dddddd;
}

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="generateds-introduction-and-tutorial">
<h1 class="title">generateDS -- Introduction and Tutorial</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Dave Kuhlman</td></tr>
<tr><th class="docinfo-name">Address:</th>
<td><pre class="address">
dkuhlman (at) davekuhlman (dot) org
<a class="last reference external" href="http://www.davekuhlman.org">http://www.davekuhlman.org</a>
</pre>
</td></tr>
</tbody>
</table>
<!-- Do not modify the following version comments.
They are used by updateversion.py. -->
<!-- version -->
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">revision:</th><td class="field-body">2.30.11</td>
</tr>
</tbody>
</table>
<!-- version -->
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">date:</th><td class="field-body">December 20, 2018</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">copyright:</th><td class="field-body">Copyright (c) 2004 Dave Kuhlman. This documentation
and the software it describes is covered by The MIT License:
<a class="reference external" href="http://www.opensource.org/licenses/mit-license">http://www.opensource.org/licenses/mit-license</a>.</td>
</tr>
<tr class="field"><th class="field-name">abstract:</th><td class="field-body">This document is an introduction and tutorial to the use
of <tt class="docutils literal">generateDS.py</tt> which generates Python data structures (for
example, class definitions) from an XML schema document.  These
data structures represent the elements in an XML document
described by the XML schema. It also generates parsers that
load an XML document into those data structures. In addition,
a separate file containing subclasses (stubs) is optionally
generated. The user can add methods to the subclasses in order
to process the contents of an XML document.</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#introduction" id="id1">1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference internal" href="#generating-the-code" id="id2">2&nbsp;&nbsp;&nbsp;Generating the code</a></li>
<li><a class="reference internal" href="#using-the-generated-code-to-parse-and-export-an-xml-document" id="id3">3&nbsp;&nbsp;&nbsp;Using the generated code to parse and export an XML document</a></li>
<li><a class="reference internal" href="#some-command-line-options-you-might-want-to-know" id="id4">4&nbsp;&nbsp;&nbsp;Some command line options you might want to know</a></li>
<li><a class="reference internal" href="#the-graphical-front-end" id="id5">5&nbsp;&nbsp;&nbsp;The graphical front-end</a></li>
<li><a class="reference internal" href="#adding-application-specific-behavior" id="id6">6&nbsp;&nbsp;&nbsp;Adding application-specific behavior</a><ul class="auto-toc">
<li><a class="reference internal" href="#implementing-custom-subclasses" id="id7">6.1&nbsp;&nbsp;&nbsp;Implementing custom subclasses</a></li>
<li><a class="reference internal" href="#using-the-generated-api-from-your-application" id="id8">6.2&nbsp;&nbsp;&nbsp;Using the generated &quot;API&quot; from your application</a></li>
<li><a class="reference internal" href="#a-combined-approach" id="id9">6.3&nbsp;&nbsp;&nbsp;A combined approach</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-situations-and-uses" id="id10">7&nbsp;&nbsp;&nbsp;Special situations and uses</a><ul class="auto-toc">
<li><a class="reference internal" href="#generic-type-independent-processing" id="id11">7.1&nbsp;&nbsp;&nbsp;Generic, type-independent processing</a><ul class="auto-toc">
<li><a class="reference internal" href="#step-1-generate-the-bindings" id="id12">7.1.1&nbsp;&nbsp;&nbsp;Step 1 -- generate the bindings</a></li>
<li><a class="reference internal" href="#step-2-add-application-specific-code" id="id13">7.1.2&nbsp;&nbsp;&nbsp;Step 2 -- add application-specific code</a></li>
<li><a class="reference internal" href="#step-3-write-a-test-driver-harness" id="id14">7.1.3&nbsp;&nbsp;&nbsp;Step 3 -- write a test/driver harness</a></li>
<li><a class="reference internal" href="#step-4-run-the-test-application" id="id15">7.1.4&nbsp;&nbsp;&nbsp;Step 4 -- run the test application</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#some-hints" id="id16">8&nbsp;&nbsp;&nbsp;Some hints</a><ul class="auto-toc">
<li><a class="reference internal" href="#children-defined-with-maxoccurs-greater-than-1" id="id17">8.1&nbsp;&nbsp;&nbsp;Children defined with maxOccurs greater than 1</a></li>
<li><a class="reference internal" href="#children-defined-with-simple-numeric-types" id="id18">8.2&nbsp;&nbsp;&nbsp;Children defined with simple numeric types</a></li>
<li><a class="reference internal" href="#the-type-of-an-element-s-character-content" id="id19">8.3&nbsp;&nbsp;&nbsp;The type of an element's character content</a></li>
<li><a class="reference internal" href="#constructors-and-their-default-values" id="id20">8.4&nbsp;&nbsp;&nbsp;Constructors and their default values</a></li>
</ul>
</li>
</ul>
</div>
<hr class="docutils" />
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id1">1&nbsp;&nbsp;&nbsp;Introduction</a></h1>
<p><strong>Additional information:</strong></p>
<ul>
<li><p class="first">If you plan to work through this tutorial, you may find it helpful
to look at the sample code that accompanies this tutorial.  You
can find it in the distribution under:</p>
<pre class="literal-block">
tutorial/
tutorial/Code/
</pre>
</li>
<li><p class="first">You can find additional information about <tt class="docutils literal">generateDS.py</tt> here:</p>
<blockquote>
<p><a class="reference external" href="http://www.davekuhlman.org/generateDS.html">http://www.davekuhlman.org/generateDS.html</a></p>
</blockquote>
<p>That documentation is also included in the distribution.</p>
</li>
</ul>
<p><tt class="docutils literal">generateDS.py</tt> generates Python data structures (for example,
class definitions) from an XML schema document. These data
structures represent the elements in an XML document described by
the XML schema.  <tt class="docutils literal">generateDS.py</tt> also generates parsers that load
an XML document into those data structures. In addition, a separate
file containing subclasses (stubs) is optionally generated. The user
can add methods to the subclasses in order to process the contents
of an XML document.</p>
<p>The generated Python code contains:</p>
<ul class="simple">
<li>A class definition for each element defined in the XML schema
document.</li>
<li>A main and driver function that can be used to test the
generated code.</li>
<li>A parser that will read an XML document which satisfies the XML
schema from which the parser was generated. The parser creates
and populates a tree structure of instances of the generated
Python classes.</li>
<li>Methods in each class to export the instance back out to XML
(method <tt class="docutils literal">export</tt>) and to export the instance to a literal
representing the Python data structure (method
<tt class="docutils literal">exportLiteral</tt>).</li>
</ul>
<p>Each generated class contains the following:</p>
<ul class="simple">
<li>A constructor method (__init__), with member variable
initializers.</li>
<li>Methods with names <tt class="docutils literal">get_xyz</tt> and <tt class="docutils literal">set_xyz</tt> for each member
variable &quot;xyz&quot; or, if the member variable is defined with
<tt class="docutils literal"><span class="pre">maxOccurs=&quot;unbounded&quot;</span></tt>, methods with names <tt class="docutils literal">get_xyz</tt>,
<tt class="docutils literal">set_xyz</tt>, <tt class="docutils literal">add_xyz</tt>, and <tt class="docutils literal">insert_xyz</tt>.  (Note: If you use
the <tt class="docutils literal"><span class="pre">--use-old-getter-setter</span></tt>, then you will get methods with
names like <tt class="docutils literal">getXyz</tt> and <tt class="docutils literal">setXyz</tt>.)</li>
<li>A <tt class="docutils literal">build</tt> method that can be used to populate an instance of the
class from a node in an ElementTree or Lxml tree.</li>
<li>An <tt class="docutils literal">export</tt> method that will write the instance (and any nested
sub-instances) to a file object as XML text.</li>
<li>An <tt class="docutils literal">exportLiteral</tt> method that will write the instance (and any
nested sub-instances) to a file object as Python literals (text).</li>
</ul>
<p>The generated subclass file contains one (sub-)class definition
for each data representation class. If the subclass file is used,
then the parser creates instances of the subclasses (instead of
creating instances of the superclasses). This enables the user to
extend the subclasses with &quot;tree walk&quot; methods, for example, that
process the contents of the XML file. The user can also generate
and extend multiple subclass files which use a single, common
superclass file, thus implementing a number of different processes
on the same XML document type.</p>
<p>This document introduces the user to <tt class="docutils literal">generateDS.py</tt> and walks the
user through several examples that show how to generate Python code
and how to use that generated code.</p>
</div>
<div class="section" id="generating-the-code">
<h1><a class="toc-backref" href="#id2">2&nbsp;&nbsp;&nbsp;Generating the code</a></h1>
<p><strong>Note:</strong> The sample files used below are under the
<tt class="docutils literal">tutorial/Code/</tt> directory.</p>
<p>Use the following to get help:</p>
<pre class="literal-block">
$ generateDS.py --help
</pre>
<p>I'll assume that <tt class="docutils literal">generateDS.py</tt> is in a directory on your path.
If not, you should do whatever is necessary to make it accessible
and executable.</p>
<p>Here is a simple XML schema document:</p>
<p>And, here is how you might generate classes and subclasses that
provide data bindings (a Python API) for the definitions in that
schema:</p>
<pre class="literal-block">
$ generateDS.py -o people_api.py -s people_sub.py people.xsd
</pre>
<p>And, if you want to automatically over-write the generated Python
files, use the <tt class="docutils literal"><span class="pre">-f</span></tt> command line flag to force over-write without
asking:</p>
<pre class="literal-block">
$ generateDS.py -f -o people_api.py -s people_sub.py people.xsd
</pre>
<p>And, to hard-wire the subclass file so that it imports the API
module, use the <tt class="docutils literal"><span class="pre">--super</span></tt> command line file.  Example:</p>
<pre class="literal-block">
$ generateDS.py -o people_api.py people.xsd
$ generateDS.py -s people_appl1.py --super=people_api people.xsd
</pre>
<p>Or, do both at the same time with the following:</p>
<pre class="literal-block">
$ generateDS.py -o people_api.py -s people_appl1.py --super=people_api people.xsd
</pre>
<p>And, for your second application:</p>
<pre class="literal-block">
$ generateDS.py -s people_appl2.py --super=people_api people.xsd
</pre>
<p>If you take a look inside these two &quot;application&quot; files, you will
see and import statement like the following:</p>
<pre class="literal-block">
import ??? as supermod
</pre>
<p>If you had not used the <tt class="docutils literal"><span class="pre">--super</span></tt> command line option when
generating the &quot;application&quot; files, then you could modify that
statement yourself.  The <tt class="docutils literal"><span class="pre">--super</span></tt> command line option does this
for you.</p>
<p>You can also use the <a class="reference internal" href="#the-graphical-front-end">The graphical front-end</a> to configure options
and save them in a session file, then use that session file with
<tt class="docutils literal">generateDS.py</tt> to specify your command line options.  For
example:</p>
<pre class="literal-block">
$ generateDS.py --session=test01.session
</pre>
<p>You can test the generated code by running it.  Try something like
the following:</p>
<pre class="literal-block">
$ python people_api.py people.xml
</pre>
<p>or:</p>
<pre class="literal-block">
$ python people_appl1.py people.xml
</pre>
<p>Why does this work?  Why can we run the generated code as a Python
script? -- If you look at the generated code, down near the end of
the file you'll find a <tt class="docutils literal">main()</tt> function that calls a function
named <tt class="docutils literal">parse()</tt>.  The <tt class="docutils literal">parse</tt> function does the following:</p>
<ol class="arabic simple">
<li>Parses your XML instance document.</li>
<li>Uses your generated API to build a tree of instances of the
generated classes.</li>
<li>Uses the <tt class="docutils literal">export()</tt> methods in that tree of instances to print
out (export) XML that represents your generated tree of
instances.</li>
</ol>
<p>Except for some indentation (ignorable whitespace), this exported
XML should be the same as the original XML document.  So, that
gives you a reasonably thorough test of your generated code.</p>
<p>And, the code in that <tt class="docutils literal">parse()</tt> function gives you a hint of how
you might build your own application-specific code that uses the
generated API (those generated Python classes).</p>
</div>
<div class="section" id="using-the-generated-code-to-parse-and-export-an-xml-document">
<h1><a class="toc-backref" href="#id3">3&nbsp;&nbsp;&nbsp;Using the generated code to parse and export an XML document</a></h1>
<p>Now that you have generated code for your data model, you can test
it by running it as an application.  Suppose that you have an
XML instance document <tt class="docutils literal">people1.xml</tt> that satisfies your schema.
Then you can parse that instance document and export it (print it
out) with something like the following:</p>
<pre class="literal-block">
$ python people_api.py people1.xml
</pre>
<p>And, if you have used the <tt class="docutils literal"><span class="pre">--super</span></tt> command line option, as I
have above, to connect your subclass file with the superclass
(API) file, then you could use the following to do the same thing:</p>
<pre class="literal-block">
$ python people_appl1.py people1.xml
</pre>
</div>
<div class="section" id="some-command-line-options-you-might-want-to-know">
<h1><a class="toc-backref" href="#id4">4&nbsp;&nbsp;&nbsp;Some command line options you might want to know</a></h1>
<p>You may want to merely skim this section for now, then later refer
back to it when some of these options are are used later in
this tutorial.  Also, remember that you can get information about
more command line options used by <tt class="docutils literal">generateDS.py</tt> by typing:</p>
<pre class="literal-block">
$ python generateDS.py --help
</pre>
<p>and by reading the document
<a class="reference external" href="http://www.davekuhlman.org/generateDS.html">http://www.davekuhlman.org/generateDS.html</a></p>
<dl class="docutils">
<dt>o</dt>
<dd>Generate the superclass module.  This is the module that
contains the implementation of each class for each element
type.  So, you can think of this as the implementation of the
&quot;data bindings&quot; or the API for XML documents of the type
defined by your XML schema.</dd>
<dt>s</dt>
<dd>Generate the subclass module.  You might or might not need
these.  If you intend to write some application-specific code,
you might want to consider starting with these skeleton classes
and add your application code there.</dd>
<dt>super</dt>
<dd>This option inserts the name of the superclass module into an
<tt class="docutils literal">import</tt> statement in the subclass file (generated with
&quot;-s&quot;).  If you know the name of the superclass file in
advance, you can use this option to enable the subclass file
to import the superclass module automatically.  If you do not
use this option, you will need to edit the
subclass module with your text editor and modify the import
statement near the top.</dd>
<dt>root-element=&quot;element-name&quot;</dt>
<dd><p class="first">Use this option to tell generateDS.py which of the elements
defined in your XM schema is the &quot;root&quot; element.  The root
element is the outer-most (top-level) element in XML instance
documents defined by this schema.  In effect, this tells your
generated modules which element to use as the root element when
parsing and exporting documents.</p>
<p class="last"><tt class="docutils literal">generateDS.py</tt> attempts to guess the root element, usually
the first element defined in your XML schema.  Use this option
when that default is not what you want.</p>
</dd>
<dt>member-specs=list|dict</dt>
<dd>Suppose you want to write some code that can be generically
applied to elements of different kinds (element types implemented
by several <em>different</em> generated classes.  If so, it might be
helpful to have a list or dictionary specifying information
about each member data item in each class.  This option does
that by generating a list or a dictionary (with the member data
item name as key) in each generated class.  Take a look at the
generated code to learn about it.  In particular, look at the
generated list or dictionary in a class for any element type
and also at the definition of the class <tt class="docutils literal">_MemberSpec</tt>
generated near the top of the API module.</dd>
<dt>version</dt>
<dd>Ask <tt class="docutils literal">generateDS.py</tt> to tell you what version it is.  This is
helpful when you want to ask about a problem, for example at
the generateds-users email list
(<a class="reference external" href="https://lists.sourceforge.net/lists/listinfo/generateds-users">https://lists.sourceforge.net/lists/listinfo/generateds-users</a>),
and want to specify which version you are using.</dd>
</dl>
</div>
<div class="section" id="the-graphical-front-end">
<h1><a class="toc-backref" href="#id5">5&nbsp;&nbsp;&nbsp;The graphical front-end</a></h1>
<p>There is also a point-and-click way to run <tt class="docutils literal">generateDS</tt>.  It
enables you to specify the options needed by <tt class="docutils literal">generateDS.py</tt>
through a graphical interface, then to run <tt class="docutils literal">generateDS.py</tt> with
those options.  It also</p>
<p>You can run it, if you have installed <tt class="docutils literal">generateDS</tt>, by typing the
following at a command line:</p>
<pre class="literal-block">
$ generateds_gui.py
</pre>
<p>After configuring options, you can save those options in a
&quot;session&quot; file, which can be loaded later.  Look under the <tt class="docutils literal">File</tt>
menu for save and load commands and also consider using the
&quot;--session&quot; command line option.</p>
<p>Also note that <tt class="docutils literal">generateDS.py</tt> itself supports a &quot;--session&quot;
command line option that enables you to run <tt class="docutils literal">generateDS.py</tt> with
the options that you specified and saved with the graphical
front-end.</p>
</div>
<div class="section" id="adding-application-specific-behavior">
<h1><a class="toc-backref" href="#id6">6&nbsp;&nbsp;&nbsp;Adding application-specific behavior</a></h1>
<p><tt class="docutils literal">generateDS.py</tt> generates Python code which, with no modification, will
parse and then export an XML document defined by your schema.  However, you
are likely to want to go beyond that.  In many situations you will want to
construct a custom application that processes your XML documents using the
generated code.</p>
<div class="section" id="implementing-custom-subclasses">
<h2><a class="toc-backref" href="#id7">6.1&nbsp;&nbsp;&nbsp;Implementing custom subclasses</a></h2>
<p>One strategy is to generate a subclass file and to add your
application-specific code to that.  Generate the subclass file
with the &quot;-s&quot; command line flag:</p>
<pre class="literal-block">
$ generateDS.py -s myapp.py people.xsd
</pre>
<p>Now add some application-specific code to <tt class="docutils literal">myapp.py</tt>, for
example, if you are using the included &quot;people&quot; sample files:</p>
<pre class="literal-block">
class peopleTypeSub(supermod.people):
    def __init__(self, comments=None, person=None, programmer=None,
        python_programmer=None, java_programmer=None):
        supermod.people.__init__(self, comments, person, programmer, python_programmer,
            java_programmer)
    def fancyexport(self, outfile):
        outfile.write('Starting fancy export')
        for person in self.get_person():
            person.fancyexport(outfile)
supermod.people.subclass = peopleTypeSub
# end class peopleTypeSub

class personTypeSub(supermod.person):
    def __init__(self, vegetable=None, fruit=None, ratio=None, id=None, value=None,
        name=None, interest=None, category=None, agent=None, promoter=None,
        description=None):
        supermod.person.__init__(self, vegetable, fruit, ratio, id, value,
            name, interest, category, agent, promoter, description)
    def fancyexport(self, outfile):
        outfile.write('Fancy person export -- name: %s' %
            self.get_name(), )
supermod.person.subclass = personTypeSub
# end class personTypeSub
</pre>
</div>
<div class="section" id="using-the-generated-api-from-your-application">
<h2><a class="toc-backref" href="#id8">6.2&nbsp;&nbsp;&nbsp;Using the generated &quot;API&quot; from your application</a></h2>
<p>In this approach you might do things like the following:</p>
<ul class="simple">
<li><tt class="docutils literal">import</tt> your generated classes.</li>
<li>Create instances of those classes.</li>
<li>Link those instances, for example put &quot;children&quot; inside of a
parent, or add one or more instances to a parent that can contain
a list of objects (think &quot;maxOccurs&quot; greater than 1 in your
schema)</li>
</ul>
<p>Get to know the generated export API by inspecting the generated
code in the superclass file.  That's the file generated with the
&quot;-o&quot; command line flag.</p>
<p>What to look for:</p>
<ul class="simple">
<li>Look at the arguments to the constructor (<tt class="docutils literal">__init__</tt>) to learn
how to initialize an instance.</li>
<li>Look at the &quot;getters&quot; and &quot;setters&quot; (methods name <tt class="docutils literal">getxxx</tt>
and <tt class="docutils literal">setxxx</tt>, to learn how to modify member variables.</li>
<li>Look for a method named <tt class="docutils literal">addxxx</tt> for members that are lists.
These correspond to members defined with <tt class="docutils literal"><span class="pre">maxOccurs=&quot;n&quot;</span></tt>, where
n &gt; 1.</li>
<li>Look at the build methods: <tt class="docutils literal">build</tt>, <tt class="docutils literal">buildChildren</tt>, and
<tt class="docutils literal">buildAttributes</tt>.  These will give you information about how
to construct each of the members of a given element/class.</li>
</ul>
<p>Now, you can import your generated API module, and use it to
construct and manipulate objects.  Here is an example using code
generated with the &quot;people&quot; schema:</p>
<pre class="literal-block">
import sys
import people_api as api

def test(names):
    people = api.peopleType()
    for count, name in enumerate(names):
        id = '%d' % (count + 1, )
        person = api.personType(name=name, id=id)
        people.add_person(person)
    people.export(sys.stdout, 0)

test(['albert', 'betsy', 'charlie'])
</pre>
<p>Run this and you might see something like the following:</p>
<pre class="literal-block">
$ python tmp.py
&lt;people &gt;
    &lt;person  id=&quot;1&quot;&gt;
        &lt;name&gt;albert&lt;/name&gt;
    &lt;/person&gt;
    &lt;person  id=&quot;2&quot;&gt;
        &lt;name&gt;betsy&lt;/name&gt;
    &lt;/person&gt;
    &lt;person  id=&quot;3&quot;&gt;
        &lt;name&gt;charlie&lt;/name&gt;
    &lt;/person&gt;
&lt;/people&gt;
</pre>
</div>
<div class="section" id="a-combined-approach">
<h2><a class="toc-backref" href="#id9">6.3&nbsp;&nbsp;&nbsp;A combined approach</a></h2>
<p><strong>Note:</strong> You can find examples of the code in this section in these
files:</p>
<pre class="literal-block">
tutorial/Code/upcase_names.py
tutorial/Code/upcase_names_appl.py
</pre>
<p>Here are the relevant, modified subclasses (<tt class="docutils literal">upcase_names_appl.py</tt>):</p>
<pre class="literal-block">
import people_api as supermod

class peopleTypeSub(supermod.peopleType):
    def __init__(self, comments=None, person=None, specialperson=None, programmer=None, python_programmer=None, java_programmer=None):
        super(peopleTypeSub, self).__init__(comments, person, specialperson, programmer, python_programmer, java_programmer, )
    def upcase_names(self):
        for person in self.get_person():
            person.upcase_names()
supermod.peopleType.subclass = peopleTypeSub
# end class peopleTypeSub

class personTypeSub(supermod.personType):
    def __init__(self, vegetable=None, fruit=None, ratio=None, id=None, value=None, name=None, interest=None, category=None, agent=None, promoter=None, description=None, range_=None, extensiontype_=None):
        super(personTypeSub, self).__init__(vegetable, fruit, ratio, id, value, name, interest, category, agent, promoter, description, range_, extensiontype_, )
    def upcase_names(self):
        self.set_name(self.get_name().upper())
supermod.personType.subclass = personTypeSub
# end class personTypeSub
</pre>
<p>Notes:</p>
<ul class="simple">
<li>These classes were generated with the &quot;-s&quot; command line option.
They are subclasses of classes in the module <tt class="docutils literal">people_api</tt>,
which was generated with the &quot;-o&quot; command line option.</li>
<li>The only modification to the skeleton subclasses is the addition
of the two methods named <tt class="docutils literal">upcase_names()</tt>.</li>
<li>In the subclass <tt class="docutils literal">peopleTypeSub</tt>, the method <tt class="docutils literal">upcase_names()</tt>
merely walk over its immediate children.</li>
<li>In the subclass <tt class="docutils literal">personTypeSub</tt>, the method <tt class="docutils literal">upcase_names()</tt>
just converts the value of its &quot;name&quot; member to upper case.</li>
</ul>
<p>Here is the application itself (<tt class="docutils literal">upcase_names.py</tt>):</p>
<pre class="literal-block">
import sys
import upcase_names_appl as appl

def create_people(names):
    people = appl.peopleTypeSub()
    for count, name in enumerate(names):
        id = '%d' % (count + 1, )
        person = appl.personTypeSub(name=name, id=id)
        people.add_person(person)
    return people

def main():
    names = ['albert', 'betsy', 'charlie']
    people = create_people(names)
    print 'Before:'
    people.export(sys.stdout, 1)
    people.upcase_names()
    print '-' * 50
    print 'After:'
    people.export(sys.stdout, 1)

main()
</pre>
<p>Notes:</p>
<ul class="simple">
<li>The <tt class="docutils literal">create_people()</tt> function creates a <tt class="docutils literal">peopleTypeSub</tt> instance
with several <tt class="docutils literal">personTypeSub</tt> instances inside it.</li>
</ul>
<p>And, when you run this mini-application, here is what you might
see:</p>
<pre class="literal-block">
$ python upcase_names.py
Before:
    &lt;people &gt;
        &lt;person  id=&quot;1&quot;&gt;
            &lt;name&gt;albert&lt;/name&gt;
        &lt;/person&gt;
        &lt;person  id=&quot;2&quot;&gt;
            &lt;name&gt;betsy&lt;/name&gt;
        &lt;/person&gt;
        &lt;person  id=&quot;3&quot;&gt;
            &lt;name&gt;charlie&lt;/name&gt;
        &lt;/person&gt;
    &lt;/people&gt;
--------------------------------------------------
After:
    &lt;people &gt;
        &lt;person  id=&quot;1&quot;&gt;
            &lt;name&gt;ALBERT&lt;/name&gt;
        &lt;/person&gt;
        &lt;person  id=&quot;2&quot;&gt;
            &lt;name&gt;BETSY&lt;/name&gt;
        &lt;/person&gt;
        &lt;person  id=&quot;3&quot;&gt;
            &lt;name&gt;CHARLIE&lt;/name&gt;
        &lt;/person&gt;
    &lt;/people&gt;
</pre>
</div>
</div>
<div class="section" id="special-situations-and-uses">
<h1><a class="toc-backref" href="#id10">7&nbsp;&nbsp;&nbsp;Special situations and uses</a></h1>
<div class="section" id="generic-type-independent-processing">
<h2><a class="toc-backref" href="#id11">7.1&nbsp;&nbsp;&nbsp;Generic, type-independent processing</a></h2>
<p>There are times when you would like to implement a function or
method that can perform operations on a variety of members <em>and</em>
that needs type information about each member.</p>
<p>You can get help with this by generating your code with the
&quot;--member-specs&quot; command line option.  When you use this option,
<tt class="docutils literal">generateDS.py</tt> add a list or a dictionary containing an item for
each member.  If you want a list, then use &quot;--member-specs=list&quot;,
and if you want a dictionary, with member names as keys, then use
&quot;--member-specs=dict&quot;.</p>
<p>Here is an example -- In this example, we walk the
document/instance tree and convert all string simple types to upper
case.</p>
<p>Here is a schema (<tt class="docutils literal">Code/member_specs.xsd</tt>):</p>
<pre class="literal-block">
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;

  &lt;xs:element name=&quot;contact-list&quot; type=&quot;contactlistType&quot; /&gt;

  &lt;xs:complexType name=&quot;contactlistType&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;description&quot; type=&quot;xs:string&quot; /&gt;
        &lt;xs:element name=&quot;contact&quot; type=&quot;contactType&quot; maxOccurs=&quot;unbounded&quot; /&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name=&quot;locator&quot; type=&quot;xs:string&quot; /&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name=&quot;contactType&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;first-name&quot; type=&quot;xs:string&quot;/&gt;
      &lt;xs:element name=&quot;last-name&quot; type=&quot;xs:string&quot;/&gt;
      &lt;xs:element name=&quot;interest&quot; type=&quot;xs:string&quot; maxOccurs=&quot;unbounded&quot; /&gt;
      &lt;xs:element name=&quot;category&quot; type=&quot;xs:integer&quot;/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name=&quot;id&quot; type=&quot;xs:integer&quot; /&gt;
    &lt;xs:attribute name=&quot;priority&quot; type=&quot;xs:float&quot; /&gt;
    &lt;xs:attribute name=&quot;color-code&quot; type=&quot;xs:string&quot; /&gt;
  &lt;/xs:complexType&gt;

&lt;/xs:schema&gt;
</pre>
<div class="section" id="step-1-generate-the-bindings">
<h3><a class="toc-backref" href="#id12">7.1.1&nbsp;&nbsp;&nbsp;Step 1 -- generate the bindings</a></h3>
<p>We generate code with the following command line:</p>
<pre class="literal-block">
$ generateDS.py -f \
  -o member_specs_api.py \
  -s member_specs_upper.py \
  --super=member_specs_api \
  --member-specs=list \
  member_specs.xsd
</pre>
<p>Notes:</p>
<ul class="simple">
<li>We generate the member specifications as a list with the command
line option <tt class="docutils literal"><span class="pre">--member-specs=list</span></tt>.</li>
<li>We generate an &quot;application&quot; module with the <tt class="docutils literal"><span class="pre">-s</span></tt> command line
option.  We'll put our application specific code in
<tt class="docutils literal">member_specs_upper.py</tt>.</li>
</ul>
</div>
<div class="section" id="step-2-add-application-specific-code">
<h3><a class="toc-backref" href="#id13">7.1.2&nbsp;&nbsp;&nbsp;Step 2 -- add application-specific code</a></h3>
<p>And, here is the subclass file (<tt class="docutils literal">member_specs_upper.py</tt>, generated
with the &quot;-s&quot; command line option), to which we have added a bit of
code that converts any string-type members to upper case.  You can
think of this module as a special &quot;application&quot; of the generated
classes.</p>
<pre class="literal-block">
#!/usr/bin/env python

#
# member_specs_upper.py
#

#
# Generated Tue Nov  9 15:54:47 2010 by generateDS.py version 2.2a.
#

import sys

import member_specs_api as supermod

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print(&quot;running with lxml.etree&quot;)
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print(&quot;running with cElementTree on Python 2.5+&quot;)
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print(&quot;running with ElementTree on Python 2.5+&quot;)
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print(&quot;running with cElementTree&quot;)
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print(&quot;running with ElementTree&quot;)
                except ImportError:
                    raise ImportError(&quot;Failed to import ElementTree from any known place&quot;)

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# Globals
#

ExternalEncoding = 'ascii'

#
# Utility funtions needed in each generated class.
#

def upper_elements(obj):
    for item in obj.member_data_items_:
        if item.get_data_type() == 'xs:string':
            name = remap(item.get_name())
            val1 = getattr(obj, name)
            if isinstance(val1, list):
                for idx, val2 in enumerate(val1):
                    val1[idx] = val2.upper()
            else:
                setattr(obj, name, val1.upper())

def remap(name):
    newname = name.replace('-', '_')
    return newname


#
# Data representation classes
#

class contactlistTypeSub(supermod.contactlistType):
    def __init__(self, locator=None, description=None, contact=None):
        super(contactlistTypeSub, self).__init__(locator, description, contact, )
    def upper(self):
        upper_elements(self)
        for child in self.get_contact():
            child.upper()
supermod.contactlistType.subclass = contactlistTypeSub
# end class contactlistTypeSub


class contactTypeSub(supermod.contactType):
    def __init__(self, priority=None, color_code=None, id=None, first_name=None, last_name=None, interest=None, category=None):
        super(contactTypeSub, self).__init__(priority, color_code, id, first_name, last_name, interest, category, )
    def upper(self):
        upper_elements(self)
supermod.contactType.subclass = contactTypeSub
# end class contactTypeSub


def get_root_tag(node):
    tag = supermod.Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = None
    if hasattr(supermod, tag):
        rootClass = getattr(supermod, tag)
    return tag, rootClass


def parse(inFilename):
    doc = parsexml_(inFilename)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'contact-list'
        rootClass = supermod.contactlistType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('&lt;?xml version=&quot;1.0&quot; ?&gt;\n')
    rootObj.export(sys.stdout, 0, name_=rootTag,
        namespacedef_='')
    doc = None
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'contact-list'
        rootClass = supermod.contactlistType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('&lt;?xml version=&quot;1.0&quot; ?&gt;\n')
    rootObj.export(sys.stdout, 0, name_=rootTag,
        namespacedef_='')
    return rootObj


def parseLiteral(inFilename):
    doc = parsexml_(inFilename)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'contact-list'
        rootClass = supermod.contactlistType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from member_specs_api import *\n\n')
    sys.stdout.write('import member_specs_api as model_\n\n')
    sys.stdout.write('rootObj = model_.contact_list(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=&quot;contact_list&quot;)
    sys.stdout.write(')\n')
    return rootObj


USAGE_TEXT = &quot;&quot;&quot;
Usage: python ???.py &lt;infilename&gt;
&quot;&quot;&quot;

def usage():
    print USAGE_TEXT
    sys.exit(1)


def main():
    args = sys.argv[1:]
    if len(args) != 1:
        usage()
    infilename = args[0]
    root = parse(infilename)


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()
</pre>
<p>Notes:</p>
<ul class="simple">
<li>We add the functions <tt class="docutils literal">upper_elements</tt> and <tt class="docutils literal">remap</tt> that we use
in each generated class.</li>
<li>Notice how the function <tt class="docutils literal">upper_elements</tt> calls the function
<tt class="docutils literal">remap</tt> <em>only</em> on those members whose type is <tt class="docutils literal">xs:string</tt>.</li>
<li>In each generated (sub-)class, we add the methods that walk the
DOM tree and apply the method (<tt class="docutils literal">upper</tt>) that transforms each
<tt class="docutils literal">xs:string</tt> value.</li>
</ul>
</div>
<div class="section" id="step-3-write-a-test-driver-harness">
<h3><a class="toc-backref" href="#id14">7.1.3&nbsp;&nbsp;&nbsp;Step 3 -- write a test/driver harness</a></h3>
<p>Here is a test driver (<tt class="docutils literal">member_specs_test.py</tt>) for our (mini-)
application:</p>
<pre class="literal-block">
#!/usr/bin/env python

#
# member_specs_test.py
#

import sys
import member_specs_api as supermod
import member_specs_upper


def process(inFilename):
    doc = supermod.parsexml_(inFilename)
    rootNode = doc.getroot()
    rootClass = member_specs_upper.contactlistTypeSub
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('&lt;?xml version=&quot;1.0&quot; ?&gt;\n')
    rootObj.export(sys.stdout, 0, name_=&quot;contact-list&quot;,
        namespacedef_='')
    rootObj.upper()
    sys.stdout.write('-' * 60)
    sys.stdout.write('\n')
    rootObj.export(sys.stdout, 0, name_=&quot;contact-list&quot;,
        namespacedef_='')
    return rootObj


USAGE_MSG = &quot;&quot;&quot;\
Synopsis:
    Sample application using classes and subclasses generated by generateDS.py
Usage:
    python member_specs_test.py infilename
&quot;&quot;&quot;

def usage():
    print USAGE_MSG
    sys.exit(1)

def main():
    args = sys.argv[1:]
    if len(args) != 1:
        usage()
    infilename = args[0]
    process(infilename)

if __name__ == '__main__':
    main()
</pre>
<p>Notes:</p>
<ul class="simple">
<li>We copy the function <tt class="docutils literal">parse()</tt> from our generated code to serve
as a model for our function <tt class="docutils literal">process()</tt>.</li>
<li>After parsing and displaying the XML instance document, we call
method <tt class="docutils literal">upper()</tt> in the generated class <tt class="docutils literal">contactlistTypeSub</tt>
in order to walk the DOM tree and transform each <tt class="docutils literal">xs:string</tt> to
uppercase.</li>
</ul>
</div>
<div class="section" id="step-4-run-the-test-application">
<h3><a class="toc-backref" href="#id15">7.1.4&nbsp;&nbsp;&nbsp;Step 4 -- run the test application</a></h3>
<p>We can use the following command line to run our application:</p>
<pre class="literal-block">
$ python member_specs_test.py member_specs_data.xml
</pre>
<p>When we run our application, here is the output:</p>
<pre class="literal-block">
$ python member_specs_test.py member_specs_data.xml
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;contact-list locator=&quot;http://www.rexx.com/~dkuhlman&quot;&gt;
    &lt;description&gt;My list of contacts&lt;/description&gt;
    &lt;contact priority=&quot;0.050000&quot; color-code=&quot;red&quot; id=&quot;1&quot;&gt;
        &lt;first-name&gt;arlene&lt;/first-name&gt;
        &lt;last-name&gt;Allen&lt;/last-name&gt;
        &lt;interest&gt;traveling&lt;/interest&gt;
        &lt;category&gt;2&lt;/category&gt;
    &lt;/contact&gt;
&lt;/contact-list&gt;
------------------------------------------------------------
&lt;contact-list locator=&quot;HTTP://WWW.REXX.COM/~DKUHLMAN&quot;&gt;
    &lt;description&gt;MY LIST OF CONTACTS&lt;/description&gt;
    &lt;contact priority=&quot;0.050000&quot; color-code=&quot;RED&quot; id=&quot;1&quot;&gt;
        &lt;first-name&gt;ARLENE&lt;/first-name&gt;
        &lt;last-name&gt;ALLEN&lt;/last-name&gt;
        &lt;interest&gt;TRAVELING&lt;/interest&gt;
        &lt;category&gt;2&lt;/category&gt;
    &lt;/contact&gt;
&lt;/contact-list&gt;
</pre>
<p>Notes:</p>
<ul class="simple">
<li>The output above shows both before- and after-version of
exporting the parsed XML instance document.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="some-hints">
<h1><a class="toc-backref" href="#id16">8&nbsp;&nbsp;&nbsp;Some hints</a></h1>
<p>The following hints are offered for convenience.  You can discover
them for yourself rather easily by inspecting the generated code.</p>
<div class="section" id="children-defined-with-maxoccurs-greater-than-1">
<h2><a class="toc-backref" href="#id17">8.1&nbsp;&nbsp;&nbsp;Children defined with maxOccurs greater than 1</a></h2>
<p>If a child element is defined in the XML schema with
<tt class="docutils literal"><span class="pre">maxOccurs=&quot;unbounded&quot;</span></tt> or a value of <tt class="docutils literal">maxOccurs</tt> greater than
1, then access to the child is through a list.</p>
</div>
<div class="section" id="children-defined-with-simple-numeric-types">
<h2><a class="toc-backref" href="#id18">8.2&nbsp;&nbsp;&nbsp;Children defined with simple numeric types</a></h2>
<p>If a child element is defined as a numeric type such as
<tt class="docutils literal">xs:integer</tt>, <tt class="docutils literal">xs:float</tt>, or <tt class="docutils literal">xs:double</tt> or as a simple type
that is (ultimately) based on a numeric type, then the value is
stored (in the Python object) as a Python data type (<tt class="docutils literal">int</tt>,
<tt class="docutils literal">float</tt>, etc).</p>
</div>
<div class="section" id="the-type-of-an-element-s-character-content">
<h2><a class="toc-backref" href="#id19">8.3&nbsp;&nbsp;&nbsp;The type of an element's character content</a></h2>
<p>But, when the element itself is defined as <tt class="docutils literal"><span class="pre">mixed=&quot;true&quot;</span></tt> or the
element a restriction of and has a simple (numeric) as a base, then
the <tt class="docutils literal">valueOf_</tt> instance variable holds the character content and
it is always a string, that is it is not converted.</p>
</div>
<div class="section" id="constructors-and-their-default-values">
<h2><a class="toc-backref" href="#id20">8.4&nbsp;&nbsp;&nbsp;Constructors and their default values</a></h2>
<p>All parameters to the constructors of generated classes have
default parameters.  Therefore, you can create an &quot;empty&quot; instance
of any element by calling the constructor with no parameters.</p>
<p>For example, suppose we have the following XML schema:</p>
<pre class="literal-block">
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;

  &lt;xs:element name=&quot;plant-list&quot; type=&quot;PlantList&quot; /&gt;

  &lt;xs:complexType name=&quot;PlantType&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;description&quot; type=&quot;xs:string&quot; /&gt;
        &lt;xs:element name=&quot;catagory&quot; type=&quot;xs:integer&quot; /&gt;
        &lt;xs:element name=&quot;fertilizer&quot; type=&quot;FertilizerType&quot; maxOccurs=&quot;unbounded&quot; /&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name=&quot;identifier&quot; type=&quot;xs:string&quot; /&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name=&quot;FertilizerType&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot;/&gt;
      &lt;xs:element name=&quot;description&quot; type=&quot;xs:string&quot;/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name=&quot;id&quot; type=&quot;xs:integer&quot; /&gt;
  &lt;/xs:complexType&gt;

&lt;/xs:schema&gt;
</pre>
<p>And, suppose we generate a module with the following command line:</p>
<pre class="literal-block">
$ ./generateDS.py -o garden_api.py garden.xsd
</pre>
<p>Then, for the element named <tt class="docutils literal">PlantType</tt> in the generated module
named <tt class="docutils literal">garden_api.py</tt>, you can create an instance as follows:</p>
<pre class="literal-block">
&gt;&gt;&gt; import garden_api
&gt;&gt;&gt; plant = garden_api.PlantType()
&gt;&gt;&gt; import sys
&gt;&gt;&gt; plant.export(sys.stdout, 0)
&lt;PlantType/&gt;
</pre>
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference external" href="generateds_tutorial.txt">View document source</a>.
Generated on: 2018-12-20 21:27 UTC.
Generated by <a class="reference external" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>
</html>
